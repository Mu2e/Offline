//
// EDAnalyzer module for reading in a root file containing art::Events
// and using a table file generated by AggregateDAQOutput to print the
// mu2e timestamps corresponding to each art::EventID. If no table file
// is provided, only the EventIDs are printed. If an EventID does not
// have a corresponding entry in the provided table file, an exception
// is thrown.
//
//
// Original author Tomonari Miyashita
//
//

// C++ includes.
#include <iostream>
#include <string>
#include <cmath>

#include <fstream>
#include <map>

// Framework includes.
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Principal/Provenance.h"
#include "cetlib_except/exception.h"

// Mu2e includes.
#include "GeometryService/inc/GeometryService.hh"
#include "GeometryService/inc/GeomHandle.hh"
//#include "GeometryService/inc/getTrackerOrThrow.hh"
#include "TrackerGeom/inc/Tracker.hh"
#include "DAQDataProducts/inc/DataBlockCollection.hh"

#include "SeedService/inc/SeedService.hh"

#include <fstream>
#include <stdexcept>

using namespace std;

namespace mu2e {

  //--------------------------------------------------------------------
  //
  //
  class ReadEventIDs : public art::EDAnalyzer {
  public:

    explicit ReadEventIDs(fhicl::ParameterSet const& pset);

    virtual void beginJob() override;

    virtual void endJob();

    void analyze( art::Event const& evt) override;

  protected:

    void flushBuffer();

    string                _outputFile;
    ofstream              outputStream;

    string _tableFile;
    ifstream inputStream;
    // Table used for mapping between DTC timestamp and
    // DataBlock timestamp

    size_t _bufferSize;
    std::vector< std::pair<DataBlock::timestamp,DataBlock::timestamp> > outputBuffer;

    std::map<DataBlock::timestamp,DataBlock::timestamp> id_to_ts_map;

    size_t numEventsProcessed;

    // Diagnostics level.
    int _diagLevel;

    // Limit on number of events for which there will be full printout.
    int _maxFullPrint;

    bool haveTableFile;

    DataBlock dummyBlock;
  };

  ReadEventIDs::ReadEventIDs(fhicl::ParameterSet const& pset):
    art::EDAnalyzer(pset),
    _outputFile                     (pset.get<string>("outputFile","parsedEventIDs.txt")),
    _tableFile                      (pset.get<string>("tableFile","tsTable.bin")),
    _bufferSize                     (pset.get<size_t>("bufferSize",1000)),
    numEventsProcessed(0),
    _diagLevel(pset.get<int>("diagLevel",0)),
    _maxFullPrint(pset.get<int>("maxFullPrint",5)),
    haveTableFile(false),
    dummyBlock()
  {
    outputStream.open(_outputFile, std::ios::out );

    inputStream.open(_tableFile, std::ios::in | std::ios::binary | std::ios::ate);
    if(inputStream.is_open()) {
      haveTableFile = true;
      
      auto size = inputStream.tellg();
      auto memblock = new char[static_cast<unsigned>(size)];
      inputStream.seekg(0, std::ios::beg);
      inputStream.read(memblock, size);
      inputStream.close();    
      
      auto curPos = reinterpret_cast<DataBlock::timestamp *>(memblock);
      while(curPos < reinterpret_cast<DataBlock::timestamp *>(memblock + sizeof(char) * size) ) {
	DataBlock::timestamp ts = static_cast<DataBlock::timestamp> (*curPos) ;
	DataBlock::timestamp uniqueID = static_cast<DataBlock::timestamp> (*(curPos+1));
	id_to_ts_map[uniqueID] = ts;
	curPos += 2;
      }
      inputStream.close();
    }

  }

  void ReadEventIDs::beginJob(){
    if ( _diagLevel > 0 ) {
      cout << "ReadEventIDs Diaglevel: "
           << _diagLevel << " "
           << _maxFullPrint
           << endl;
    }
  }

  void ReadEventIDs::endJob(){
    flushBuffer();
    outputStream.close();

    if (_diagLevel > 0) {
      cout << "ReadEventIDs: "
	   << "Finished writing "
	   << numEventsProcessed
	   << " events to "
	   << _outputFile
	   << endl;
    }

  }

  void ReadEventIDs::flushBuffer() {

    for(size_t idx = 0; idx<outputBuffer.size(); idx++) {
      outputStream << outputBuffer[idx].first;
      if(haveTableFile) {
	outputStream << "\t";
	outputStream << outputBuffer[idx].second;
      }
      outputStream << "\n";
    }
    outputStream << std::flush;
    outputBuffer.clear();
  }

  void ReadEventIDs::analyze(art::Event const& evt) {

    DataBlock::timestamp ts = 0;
    art::EventID evtId = evt.id();

    DataBlock::timestamp uniqueID = dummyBlock.generateUniqueID(evtId);

    if(haveTableFile) {
      // Note: ::at() throws an exception of the element doesn't exist in the dictionary
      ts = id_to_ts_map.at(uniqueID);
    } 

    std::pair<DataBlock::timestamp,DataBlock::timestamp> curPair(uniqueID,ts);

    if(outputBuffer.size() >= _bufferSize) {
      flushBuffer();
    }
    outputBuffer.push_back(curPair);

    numEventsProcessed += 1;

  } // end of ::analyze.

}

using mu2e::ReadEventIDs;
DEFINE_ART_MODULE(ReadEventIDs);
