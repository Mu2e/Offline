//
// Namespace for collecting tools used in MC truth evaluation
// Original author: Dave Brown (LBNL) 8/10/2016
//
#ifndef TrkDiag_TrkMCTools_hh
#define TrkDiag_TrkMCTools_hh
#include "Offline/RecoDataProducts/inc/StrawHitIndex.hh"
#include "Offline/MCDataProducts/inc/StrawDigiMC.hh"
#include "Offline/MCDataProducts/inc/StepPointMC.hh"

#include "Offline/RecoDataProducts/inc/KalSeed.hh"
#include "Offline/MCDataProducts/inc/KalSeedMC.hh"
#include "Offline/MCDataProducts/inc/PrimaryParticle.hh"

#include <vector>
#include <functional>
namespace mu2e {
  namespace TrkMCTools {
    /////////////////////////////
    // Straw Hit Level Utilities

    // determine if a hit was generated by signal (conversion electron)
    bool CEDigi(StrawDigiMC const& mcdigi);
    // count the number of digis produced by the given particle
    unsigned countDigis(art::Ptr<SimParticle> const& pspp, const StrawDigiMCCollection* mcdigis);
    // determine the sim particle which originated most of the hits specified in the specified set of digis
    unsigned primaryParticle(art::Ptr<SimParticle>& pspp, std::vector<StrawHitIndex> const& hits, const StrawDigiMCCollection* mcdigis);
    // determine the sim particle corresponding to a digi
    unsigned simParticle(art::Ptr<SimParticle>& spp, StrawDigiMC const& digimc);

    /////////////////////////////
    // Track Level Utilities
    struct spcount {
      spcount() : _count(0), _acount(0) {}
      spcount(art::Ptr<SimParticle> const& spp) : _spp(spp), _count(0), _acount(0) {}
      spcount(art::Ptr<SimParticle> const& spp,bool active) : _spp(spp), _count(1), _acount(0) {
        if(active)_acount =1; }
      void append(art::Ptr<SimParticle> const& sp,bool active) { if(sp == _spp){
        ++_count; if(active)++_acount; } }
      bool operator ==(art::Ptr<SimParticle> const& sp) const { return _spp == sp; }
      art::Ptr<SimParticle> _spp;
      unsigned _count; // counts all hits
      unsigned _acount; // counts active
    };
    // sort by active hits
    struct spcountcomp {
      bool operator() (spcount a, spcount b) { return a._acount > b._acount; }
    };

    typedef StepPointMCCollection::const_iterator MCStepItr;
    struct timecomp {
      bool operator()(MCStepItr x,MCStepItr y) { return x->time() < y->time(); }
    };

    // find associated sim particles to a track.  The first returns a hit-weighted vector of
    // all particles, the second just the one with the most hits
    void findMCTrk(const KalSeed& kseed, art::Ptr<SimParticle>& spp, const StrawDigiMCCollection& mcdigis);
    void findMCTrk(const KalSeed& kseed, std::vector<spcount>& sct, const StrawDigiMCCollection& mcdigis,bool saveall=false);

    // find steps associated with a given SimParticle ID
    void findMCSteps(const StepPointMCCollection& mcsteps, cet::map_vector_key const& trkid, std::vector<int> const& vids, std::vector<MCStepItr>& steps);

    // count types of hits and digis
    void countDigis(const KalSeedMC& kseedmc, const KalSeed& kseed, int& ndigi, int& digigood, int& ngood);

    // find relationship of a set of StrawDigis to the primary particle in the event
    void primaryRelation(PrimaryParticle const& primary,
        StrawDigiMCCollection const& sdmccol, std::vector<StrawDigiIndex> const& indices,
        art::Ptr<SimParticle>& primarysim, unsigned& nprimary, MCRelationship& mcrel);

  }
}

#endif
