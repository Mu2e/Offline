////////////////////////////////////////////////////////////////////////
// Class:       BeamTestAnalysis
// Module Type: analyzer
// File:        BeamTestAnalysis_module.cc
//
// Generated at Tue Dec  8 11:55:08 2015 by aedmonds using artmod
// from cetpkgsupport v1_08_07.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <iostream>
#include "MCDataProducts/inc/StepPointMCCollection.hh"
#include "art_root_io/TFileService.h"
#include "GeometryService/inc/GeometryService.hh"
#include "GeometryService/inc/GeomHandle.hh"
#include "TTrackerGeom/inc/TTracker.hh"
#include "GlobalConstantsService/inc/GlobalConstantsHandle.hh"
#include "GlobalConstantsService/inc/ParticleDataTable.hh"
#include "TH2.h"
#include "TH3.h"

namespace mu2e {
  class BeamTestAnalysis;
}

class mu2e::BeamTestAnalysis : public art::EDAnalyzer {
public:
  explicit BeamTestAnalysis(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  BeamTestAnalysis(BeamTestAnalysis const &) = delete;
  BeamTestAnalysis(BeamTestAnalysis &&) = delete;
  BeamTestAnalysis & operator = (BeamTestAnalysis const &) = delete;
  BeamTestAnalysis & operator = (BeamTestAnalysis &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  //
  virtual void beginJob() override;
  virtual void endJob() override;

  // Copied from StepPointMCDumper_module.cc
  double getKineticEnergy(const StepPointMC& hit) {
    // unlike generic conditions, MC particle data
    // should not change run-to-run, so static is safe
    // use static for efficiency
    static GlobalConstantsHandle<ParticleDataTable> pdt;

    ParticleDataTable::maybe_ref info = pdt->particle(hit.simParticle()->pdgId());

    if(!info.isValid()) {
      throw cet::exception("MISSINGINFO")<<"No valid PDG info for hit = "<<hit<<"\n";
    }

    const double mass = info.ref().mass();
    return sqrt(hit.momentum().mag2() + std::pow(mass, 2)) - mass;
  }


private:

  // Declare member data here.
  TH3F* hPosition;
  TH2D* hKineticEnergy_ZPos;
  TH1D* hEDep;
  TH1D* hKineticEnergy_FirstLayer;
  TH2D* hPosition_XYFirstLayer;
  TH1D* hTime_FirstLayer;
  TH1D* hNeutronRate_ZPos;
  TH3F* hOriginPosition_NonNeutron;
  TH3F* hOriginPosition_Neutron;
  TH1D* hPDGNumbers;

  std::vector<std::string> fTrackerVolumes;
  std::vector<double> fG10ZPositions;
  double fZPositionLimit;

  double fG10SurfaceArea;

  int fNEvents;
};


mu2e::BeamTestAnalysis::BeamTestAnalysis(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p), hPosition(0), fNEvents(0)
{}

void mu2e::BeamTestAnalysis::beginJob() {

  // Store the volume names that we are interested in
  fTrackerVolumes.push_back("TTrackerSupportElecG10Upstream");
  fTrackerVolumes.push_back("TTrackerSupportElecG10Downstream");

  // Create the histogram
  art::ServiceHandle<art::TFileService> tfs;
  
  double bin_width = 10;
  double min_x = -4800;
  double max_x = -3000;
  int n_bins_x = (max_x - min_x) / bin_width;
  double min_y = -800;
  double max_y = 800;
  int n_bins_y = (max_y - min_y) / bin_width;
  double min_z = 8500;
  double max_z = 12000;
  int n_bins_z = (max_z - min_z) / bin_width;
  hPosition = tfs->make<TH3F>("hPosition", "hPosition", n_bins_x,min_x,max_x, n_bins_y,min_y,max_y, n_bins_z,min_z,max_z);
  hPosition->SetXTitle("X [mm]");
  hPosition->SetYTitle("Y [mm]");
  hPosition->SetZTitle("Z [mm]");

  double energy_bin_width = 0.1; // MeV                                                                                                                                                 
  double min_kinetic_energy = 0;
  double max_kinetic_energy = 100;
  int n_bins_ke = (max_kinetic_energy - min_kinetic_energy) / energy_bin_width;
  hKineticEnergy_ZPos = tfs->make<TH2D>("hKineticEnergy_ZPos", "hKineticEnergy_ZPos", n_bins_ke,min_kinetic_energy,max_kinetic_energy, n_bins_z,min_z,max_z);
  hKineticEnergy_ZPos->SetXTitle("Kinetic Energy [MeV]");
  hKineticEnergy_ZPos->SetYTitle("Z [mm]");

  hKineticEnergy_FirstLayer = tfs->make<TH1D>("hKineticEnergy_FirstLayer", "hKineticEnergy_FirstLayer", n_bins_ke,min_kinetic_energy,max_kinetic_energy);
  hKineticEnergy_FirstLayer->SetXTitle("Kinetic Energy [MeV]");
  hKineticEnergy_FirstLayer->SetYTitle("StepPointMCs per 0.1 MeV");

  double edep_bin_width = 0.01;
  double min_edep = 0;
  double max_edep = 4;
  int n_bins_edep = (max_edep - min_edep) / edep_bin_width;
  hEDep = tfs->make<TH1D>("hEDep", "hEDep", n_bins_edep,min_edep,max_edep);
  hEDep->SetXTitle("Total Energy Deposited [MeV]");
  hEDep->SetYTitle("StepPointMCs per 0.01 MeV");

  hPosition_XYFirstLayer = tfs->make<TH2D>("hPosition_XYFirstLayer", "hPosition_XYFirstLayer", n_bins_x,min_x,max_x, n_bins_y,min_y,max_y);
  hPosition_XYFirstLayer->SetXTitle("X [mm]");
  hPosition_XYFirstLayer->SetYTitle("Y [mm]");

  double time_width = 10;
  double min_time = 0;
  double max_time = 10000;
  int n_bins_time = (max_time - min_time) / time_width;
  hTime_FirstLayer = tfs->make<TH1D>("hTime_FirstLayer", "hTime_FirstLayer", n_bins_time,min_time,max_time);  
  hTime_FirstLayer->SetXTitle("Time [ns]");

  hNeutronRate_ZPos = tfs->make<TH1D>("hNeutronRate_ZPos", "hNeutronRate_ZPos", n_bins_z,min_z,max_z);
  hNeutronRate_ZPos->SetXTitle("Z [mm]");


  bin_width = 10;
  min_x = -5000;
  max_x = -2800;
  n_bins_x = (max_x - min_x) / bin_width;
  min_y = -1000;
  max_y = 1000;
  n_bins_y = (max_y - min_y) / bin_width;
  min_z = 0;
  max_z = 12000;
  n_bins_z = (max_z - min_z) / bin_width;
  hOriginPosition_NonNeutron = tfs->make<TH3F>("hOriginPosition_NonNeutron", "hOriginPosition_NonNeutron", n_bins_x,min_x,max_x, n_bins_y,min_y,max_y, n_bins_z,min_z,max_z);
  hOriginPosition_NonNeutron->SetXTitle("X [mm]");
  hOriginPosition_NonNeutron->SetYTitle("Y [mm]");
  hOriginPosition_NonNeutron->SetZTitle("Z [mm]");
  hOriginPosition_Neutron = tfs->make<TH3F>("hOriginPosition_Neutron", "hOriginPosition_Neutron", n_bins_x,min_x,max_x, n_bins_y,min_y,max_y, n_bins_z,min_z,max_z);
  hOriginPosition_Neutron->SetXTitle("X [mm]");
  hOriginPosition_Neutron->SetYTitle("Y [mm]");
  hOriginPosition_Neutron->SetZTitle("Z [mm]");

  hPDGNumbers = tfs->make<TH1D>("hPDGNumbers", "hPDGNumbers", 5000,0,5000);
  //  hPDGNumbers->SetBit(TH1::kCanRebin);
  hPDGNumbers->SetXTitle("PDG ID");
}  

void mu2e::BeamTestAnalysis::endJob() {
  
  // Normalise the plots
  double microbunch_width = 1700; // ns

  /*  double time_bin_width = hTime_FirstLayer->GetXaxis()->GetBinWidth(1);
  hTime_FirstLayer->Scale(1.0/time_bin_width); // scale to be per ns
  hTime_FirstLayer->Scale(1e9); // now be per s
  hTime_FirstLayer->SetYTitle("Hit Rate [Hz]");
  */
  //  double peak_hit_rate = hTime_FirstLayer->GetMaximum();
  double total_hits = hTime_FirstLayer->GetEntries();
  //  std::cout << "BeamTestAnalysis: Peak Hit Rate = " << peak_hit_rate << " Hz" << std::endl;
  std::cout << "BeamTestAnalysis: Total StepPointMCs in First Layer = " << total_hits << " incoming neutrons" << std::endl;
  //  std::cout << "BeamTestAnalysis: Neutron fluence = " << peak_hit_rate / (fG10SurfaceArea/100) << " neutrons cm^-2 s^-1" << std::endl;
  //  std::cout << "BeamTestAnalysis: or, neutron fluence = " << total_hits / ((fG10SurfaceArea/100) * (10000/1e9)) << " neutrons cm^-2 s^-1" << std::endl << std::endl;

  //  double peak_hits_xy = hPosition_XYFirstLayer->GetMaximum();
  //  double hits_per_simulated_neutron = peak_hits_xy / fNEvents;
  double total_hits_per_simulated_neutron = total_hits / fNEvents;
  //  std::cout << "BeamTestAnalysis: Peak Hits (XY First Layer) = " << peak_hits_xy << " hits cm^-2" << std::endl;
  std::cout << "BeamTestAnalysis: N Simulated Neutrons = " << fNEvents << " emitted neutrons" << std::endl;
  //  std::cout << "BeamTestAnalysis: Peak Hits per Simulated Neutron = " << hits_per_simulated_neutron << std::endl << std::endl;
  std::cout << "BeamTestAnalysis: Total StepPointMCs per Simulated Neutron = " << total_hits_per_simulated_neutron << " incoming neutrons per emitted neutron" << std::endl;

  double neutrons_per_capture = 1.2;
  double fraction_captured = 0.61;
  double stops_per_POT = 0.00187;
  double POT_per_microbunch = 3.9e7;
  std::cout << "BeamTestAnalysis: Neutrons Emitted per Capture = " << neutrons_per_capture << " emitted neutrons per muon capture" << std::endl;
  std::cout << "BeamTestAnalysis: Fraction of Muons Captured = " << fraction_captured << " captured muons per muon stop" << std::endl;
  std::cout << "BeamTestAnalysis: Number of Muons Stopped per POT = " << stops_per_POT << " muon stops per POT" << std::endl;
  std::cout << "BeamTestAnalysis: Number of POT per Microbunch = " << POT_per_microbunch << " POT per microbunch" << std::endl << std::endl;

  double hits_per_microbunch = (total_hits_per_simulated_neutron * neutrons_per_capture * fraction_captured * stops_per_POT * POT_per_microbunch);
  double hits_per_second = hits_per_microbunch / (microbunch_width/1e9);
  double neutron_fluence = hits_per_second / (fG10SurfaceArea/100);
  std::cout << "BeamTestAnalysis: StepPointMCs per Microbunch = " << hits_per_microbunch << " incoming neutrons per microbunch" << std::endl;
  std::cout << "BeamTestAnalysis: Microbunch Length = " << microbunch_width << " ns" << std::endl;
  std::cout << "BeamTestAnalysis: StepPointMCs per Second = " << hits_per_second << " incoming neutrons s^-1" << std::endl;
  std::cout << "BeamTestAnalysis: G10 Surface Area = " << fG10SurfaceArea << " mm^2" << std::endl;
  std::cout << "BeamTestAnalysis: Peak StepPointMC Rate = " << neutron_fluence << " incoming neutrons cm^-2 s^-1" << std::endl;


  hNeutronRate_ZPos->Scale(1.0/fNEvents); // scale to be per emitted neutron
  hNeutronRate_ZPos->Scale(neutrons_per_capture * fraction_captured * stops_per_POT * POT_per_microbunch); // scale to be per microbunch
  hNeutronRate_ZPos->Scale(1.0/(microbunch_width/1e9)); // scale to be per s
  hNeutronRate_ZPos->Scale(1.0/(fG10SurfaceArea/100)); // scale to be per cm^2
  hNeutronRate_ZPos->SetYTitle("Neutron Rate [neutrons cm^{-2} s^{-1}]");
  hNeutronRate_ZPos->SetTitle("Rate of Incoming Neutrons in each G10 Volume");
}

void mu2e::BeamTestAnalysis::analyze(art::Event const & e)
{
  ++fNEvents;

  // Get all the information we need from the geometry
  if (fG10ZPositions.empty()) { // only do it once
    art::ServiceHandle<GeometryService> geom;

    if ( !geom->hasElement<TTracker>() ){
      std::cerr << "No TTracker geometry" << std::endl;
      return;
    }
    GeomHandle<TTracker> ttracker;
    const std::vector<Station>& stations = ttracker->getStations();
    for (const auto& i_station : stations) {
      
      const std::vector<Plane>& planes = i_station.getPlanes();
      for (const auto& i_plane : planes) {
	
	const std::vector<Face>& faces = i_plane.getFaces();
	for (const auto& i_face : faces) {
	  
	  // Don't want to go any further because the next level down (panels) all have the same z-position
	  //	std::cout << "Station #" << i_station.id() << ", Plane #" << i_plane.id() << ", Face #" << i_face.id() <<
	  //	  ": z = " << ttracker->z0()+i_face.midZ() << " (" << ttracker->z0()+i_face.midZ()+ttracker->getSupportStructure().g10Upstream().position().z() << " - " << ttracker->z0()+i_face.midZ()- << ")" << std::endl;
	  fG10ZPositions.push_back(ttracker->z0()+i_face.midZ());
	  fZPositionLimit = -ttracker->getSupportStructure().g10Upstream().position().z() - ttracker->getSupportStructure().gasUpstream().position().z();
	  //	  std::cout << "ZPositionLimit = " << fZPositionLimit << std::endl;
	}
      }
    }

    // Calcute the surface area of the G10
    double g10_outer_radius = ttracker->getSupportStructure().g10Upstream().outerRadius();
    double outer_radius_area = CLHEP::pi*g10_outer_radius*g10_outer_radius;
    double g10_inner_radius = ttracker->getSupportStructure().g10Upstream().innerRadius();
    double inner_radius_area = CLHEP::pi*g10_inner_radius*g10_inner_radius;
    fG10SurfaceArea = outer_radius_area - inner_radius_area;
    
  }

  // Loop through the volumes we are interested in
  for (const auto& i_vol_name : fTrackerVolumes) {
    art::Handle<StepPointMCCollection> hitsHandle;
    e.getByLabel("g4run",i_vol_name,hitsHandle);
    StepPointMCCollection const& hits(*hitsHandle);
    
    if (hits.empty()) {
      //      std::cerr << "No StepPointMCs in " << i_vol_name << ". Continuing in event: " << e.id() << std::endl;
      continue;
    }
    
    std::vector<double> g10_zpositions_seen;
    cet::map_vector_key prev_track_id;

    for (const auto& i_hit : hits) {
      //      std::cout << "Track ID = " << i_hit.trackId().asInt() << ", z = " << i_hit.position().z() << std::endl;

      // Want to record the positions of everything
      hPosition->SetTitle("Hit Positions (All particles, all StepPointMCs)");
      hPosition->Fill(i_hit.position().x(), i_hit.position().y(), i_hit.position().z());

      // Also want to record all the energy deposits regardless of particle type and regardless if it's made multiple hits in the same volume
      hEDep->SetTitle("Total Energy Desposited (All particles, all StepPointMCs in first layer z < 8700 mm)");
      if (i_hit.position().z() < 8700) {
	hEDep->Fill(i_hit.totalEDep());
      }


      // The variables we want to know
      double kinetic_energy = 0;
      cet::map_vector_key this_track_id = i_hit.trackId();

      if (prev_track_id != this_track_id) { // new track
	g10_zpositions_seen.clear(); // reset this
	prev_track_id = this_track_id;
      }

      // Loop through all the G10 z-positions and try and assign this hit to a certain G10 volume
      bool matched = false;
      for (const auto& i_zpos : fG10ZPositions) {

	if (std::fabs(i_zpos - i_hit.position().z()) <= fZPositionLimit) { // we have found the correct G10 volume for this hit
	
	  matched = true;

	  // Loop through the previous G10 z positions we've seen
	  bool seen = false;
	  for (const auto& i_seen : g10_zpositions_seen) {

	    if (std::fabs(i_hit.position().z() - i_seen) <= fZPositionLimit) {
	      // Already seen a StepPointMC in this region
	      seen = true;
	      break;
	    }
	  }

	  if (!seen) {
	    // Haven't seen a StepPointMC in this region before, so assume it is the first and is the incident kinetic energy
	    kinetic_energy = getKineticEnergy(i_hit);

	    // If it's a neutron record it's kinetic energy
	    if (i_hit.simParticle()->pdgId() == 2112) {
	      hKineticEnergy_ZPos->SetTitle("Kinetic Energy vs Z Position (for first neutron StepPointMC in each G10 volume)");
	      hKineticEnergy_ZPos->Fill(kinetic_energy, i_hit.position().z());

	      hNeutronRate_ZPos->Fill(i_hit.position().z());

	      if (i_hit.position().z() < 8700) {
		hKineticEnergy_FirstLayer->SetTitle("Kinetic Energy in First Layer (z < 8700 mm, first neutron StepPointMC)");
		hKineticEnergy_FirstLayer->Fill(kinetic_energy);
		
		hPosition_XYFirstLayer->SetTitle("XY StepPoint Position for incoming neutrons (z < 8700 mm)");
		hPosition_XYFirstLayer->Fill(i_hit.position().x(), i_hit.position().y());
		
		hTime_FirstLayer->SetTitle("Time for incoming neutrons (z < 8700 mm)");
		hTime_FirstLayer->Fill(i_hit.time());
	      }
	      hOriginPosition_Neutron->SetTitle("Origin Position of Incoming Neutrons");
	      hOriginPosition_Neutron->Fill(i_hit.simParticle()->startPosition().x(),i_hit.simParticle()->startPosition().y(),i_hit.simParticle()->startPosition().z());

	    }


	    // and now we've seen a hit in this region
	    g10_zpositions_seen.push_back(i_zpos);
	  }
	}
      }
      if (!matched) {
	std::cerr << "Couldn't match a G10 volume z-position with the z-position of this track. Continuing through event: " << e.id() << std::endl;
	continue;
      }

      // Before filling in the kinetic energy plot, check that it's a neutron
      //      if (i_hit.simParticle()->pdgId() == 2112) {

      //      }
      if (i_hit.simParticle()->pdgId() != 2112) {
	// For all other particles record their origin position
	hOriginPosition_NonNeutron->Fill(i_hit.simParticle()->startPosition().x(),i_hit.simParticle()->startPosition().y(),i_hit.simParticle()->startPosition().z());
	hPDGNumbers->Fill(i_hit.simParticle()->pdgId());

	//	if (i_hit.simParticle()->pdgId() > 5000) {
	//	  std::cout << "PDG Histogram Overflow: Value = " << i_hit.simParticle()->pdgId() << std::endl;
	//	}
      }
    }
  }
}

DEFINE_ART_MODULE(mu2e::BeamTestAnalysis)
