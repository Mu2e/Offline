////////////////////////////////////////////////////////////////////////
// Class:       PrescaleEvent
// Module Type: filter
// File:        PrescaleEvent_module.cc
//
// Generated at Tue Jan  6 11:52:08 2015 by John Freeman using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/types/Atom.h"
#include "fhiclcpp/types/Sequence.h"
#include "fhiclcpp/types/Table.h"
#include "canvas/Utilities/InputTag.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
// #include "RecoDataProducts/inc/TriggerInfo.hh"
#include "Offline/DataProducts/inc/EventWindowMarker.hh"
#include "artdaq-core-mu2e/Data/EventHeader.hh"

#include <memory>
#include <iostream>

namespace mu2e
{

  class PrescaleEvent : public art::EDFilter {

  public:

    using  Name    = fhicl::Name;
    using  Comment = fhicl::Comment;

    struct EventModeConfig {
      //fhicl::Atom<uint8_t>        eventMode{ Name("eventMode"), Comment("EventMode: OnSpill, OffSpill, Calib, ...")};//FIXME!!
      fhicl::Atom<std::string>        eventMode{ Name("eventMode"), Comment("EventMode: OnSpill, OffSpill, Calib, ...")};//FIXME!!
      fhicl::Atom<float >         prescale { Name("prescale") , Comment("Prescale factor")};
    };

    struct Config {
      fhicl::Atom<art::InputTag>                       EWM       { Name("EventWindowMarker"), Comment("EventWindowMarker"),"EWMProducer"};
      fhicl::Atom<int>                                 debug     { Name("debugLevel")     , Comment("Debug Level"), 0};
      fhicl::Sequence<fhicl::Table<EventModeConfig>>   eventMode { Name("eventModeConfig"), Comment("List of the Event modes with their PS factor")};
    };
    using        Parameters = art::EDFilter::Table<Config>;
    explicit     PrescaleEvent(const Parameters& conf);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    // Plugins should not be copied or assigned.

    PrescaleEvent(PrescaleEvent const &) = delete;
    PrescaleEvent(PrescaleEvent &&) = delete;
    PrescaleEvent & operator = (PrescaleEvent const &) = delete;
    PrescaleEvent & operator = (PrescaleEvent &&) = delete;

    bool filter(art::Event & e) override;
    virtual bool endRun(art::Run& run ) override;

  private:

    art::ProductToken<EventWindowMarker> const _ewmtoken;
    std::vector<EventModeConfig> _eventMode;
    int                  _debug;
    unsigned             _nevt, _npass;

  };

  PrescaleEvent::PrescaleEvent(Parameters const & config) :
    art::EDFilter{config},
    _ewmtoken{consumes<EventWindowMarker>(config().EWM())},
    _eventMode     (config().eventMode()),
    _debug         (config().debug()),
    _nevt(0), _npass(0){}

  inline bool PrescaleEvent::filter(art::Event & e)
  {
    ++_nevt;

    auto ewmH = e.getValidHandle(_ewmtoken);
    const EventWindowMarker& ewm(*ewmH);
    int ps(0);
    for (size_t i=0;i<_eventMode.size();++i){
      uint8_t spillType;
      // FIXME is event mode a mask?
      if (_eventMode[i].eventMode() == "OffSpill"){
        spillType = EventWindowMarker::offspill;
      }else if (_eventMode[i].eventMode() == "OnSpill"){
        spillType = EventWindowMarker::onspill;
      }else{
        std::cout << "PrescaleEvent: unknown eventMode " << _eventMode[i].eventMode() << std::endl;
        continue;
      }
      if (spillType == ewm.spillType()){
        ps = _eventMode[i].prescale();
        break;
      }
    }

    bool retval(false);

    if(ps > 0) {
      retval = e.event() % ps == 0;
      if (retval){
        ++_npass;
      }
    }
    return retval;
  }

  bool PrescaleEvent::endRun( art::Run& run ) {
    if(_debug > 0){
      std::cout << moduleDescription().moduleLabel() << " passed " << _npass << " events out of " << _nevt << " for a ratio of " << float(_npass)/float(_nevt) << std::endl;
    }
    return true;
  }

}
using mu2e::PrescaleEvent;
DEFINE_ART_MODULE(PrescaleEvent)
