////////////////////////////////////////////////////////////////////////
// Class:       PrescaleEvent
// Module Type: filter
// File:        PrescaleEvent_module.cc
//
// Generated at Tue Jan  6 11:52:08 2015 by John Freeman using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/types/Atom.h"
#include "fhiclcpp/types/Sequence.h"
#include "fhiclcpp/types/Table.h"
#include "canvas/Utilities/InputTag.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "Offline/DataProducts/inc/EventWindowMarker.hh"
#include "Offline/DataProducts/inc/FilterFraction.hh"
#include "artdaq-core-mu2e/Data/EventHeader.hh"

#include <memory>
#include <iostream>
#include <string>

namespace mu2e
{

  class PrescaleEvent : public art::EDFilter {

  public:

    using  Name    = fhicl::Name;
    using  Comment = fhicl::Comment;

    struct EventModeConfig {
      fhicl::Atom<std::string>   eventMode{ Name("eventMode"), Comment("EventMode: OnSpill, OffSpill, Calib, ...")};
      fhicl::Atom<int>           prescale { Name("prescale") , Comment("Prescale factor")};
    };

    struct EventMode {
      EventWindowMarker::SpillType type_;
      int prescale_;
      std::string name_;
      EventMode(EventWindowMarker::SpillType type, int prescale, std::string const& name ) : type_(type), prescale_(prescale), name_(name) {}
    };

    struct Config {
      fhicl::Atom<art::InputTag>                       EWM       { Name("EventWindowMarker"), Comment("EventWindowMarker"),"EWMProducer"};
      fhicl::Atom<int>                                 debug     { Name("debugLevel")     , Comment("Debug Level"), 0};
      fhicl::Sequence<fhicl::Table<EventModeConfig>>   eventMode { Name("eventModeConfig"), Comment("List of the Event modes with their PS factor")};
    };
    using        Parameters = art::EDFilter::Table<Config>;
    explicit     PrescaleEvent(const Parameters& conf);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    // Plugins should not be copied or assigned.

    PrescaleEvent(PrescaleEvent const &) = delete;
    PrescaleEvent(PrescaleEvent &&) = delete;
    PrescaleEvent & operator = (PrescaleEvent const &) = delete;
    PrescaleEvent & operator = (PrescaleEvent &&) = delete;

    bool filter(art::Event & e) override;
    bool endSubRun(art::SubRun& subrun ) override;

  private:

    art::ProductToken<EventWindowMarker> const ewmtoken_;
    std::vector<EventMode>              eventMode_;
    std::vector<uint64_t>     nevt_, npass_;
    int                                 debug_;
  };

  PrescaleEvent::PrescaleEvent(Parameters const & config) :
    art::EDFilter{config},
    ewmtoken_{consumes<EventWindowMarker>(config().EWM())},
    nevt_(config().eventMode().size(),0),
    npass_(config().eventMode().size(),0),
    debug_         (config().debug()) {
    for(const auto& mode : config().eventMode()) {
      if(mode.eventMode() == "OffSpill") eventMode_.push_back(EventMode(EventWindowMarker::offspill, mode.prescale(),mode.eventMode()));
      else if(mode.eventMode() == "OnSpill") eventMode_.push_back(EventMode(EventWindowMarker::onspill, mode.prescale(),mode.eventMode()));
      else throw cet::exception("TRIGGER") << "Unknown prescale mode " << mode.eventMode();
      produces<mu2e::FilterFraction,art::InSubRun>(mode.eventMode());
    }
  }

  inline bool PrescaleEvent::filter(art::Event & e)
  {
    // Check for the prescale corresponding to the current event mode
    auto ewmH = e.getValidHandle(ewmtoken_);
    const EventWindowMarker& ewm(*ewmH);
    for (size_t imode = 0; imode < eventMode_.size(); imode++){
      auto const& mode = eventMode_[imode];
      uint8_t spillType = mode.type_;
      if (spillType == ewm.spillType()){
        ++nevt_[imode];
    // Apply the prescale
        bool retval = e.event() % mode.prescale_ == 0;
        if (retval) ++npass_[imode];
        return retval;
      }
    }
    // If no matching event type is found, return false
    return false;
  }

  bool PrescaleEvent::endSubRun( art::SubRun& subrun ) {
    for (size_t imode = 0; imode < eventMode_.size(); imode++){
      auto const& mode = eventMode_[imode];
      double frac = 1.0/double(mode.prescale_);
      auto ff = std::make_unique<FilterFraction>(FilterFraction::constant, frac, nevt_[imode],npass_[imode]);
      subrun.put(std::move(ff),mode.name_,art::fullSubRun());
      if(debug_ > 0){
        std::cout << moduleDescription().moduleLabel() << " mode " << mode.name_ << " passed " << npass_[imode] << " events out of " << nevt_[imode]
          << " for a ratio of " << ((nevt_[imode] > 0) ? double(npass_[imode])/double(nevt_[imode]) : 0.f) << std::endl;
      }
      // reset
      npass_[imode] = 0; nevt_[imode] = 0;
    }
    return true;
  }
}

using mu2e::PrescaleEvent;
DEFINE_ART_MODULE(PrescaleEvent)
