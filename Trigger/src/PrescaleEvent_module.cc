////////////////////////////////////////////////////////////////////////
// Class:       PrescaleEvent
// Module Type: filter
// File:        PrescaleEvent_module.cc
//
// Generated at Tue Jan  6 11:52:08 2015 by John Freeman using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/types/Atom.h"
#include "fhiclcpp/types/Sequence.h"
#include "fhiclcpp/types/Table.h"
#include "canvas/Utilities/InputTag.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
// #include "RecoDataProducts/inc/TriggerInfo.hh"
#include "artdaq-core-mu2e/Data/EventHeader.hh"

#include <memory>
#include <iostream>

namespace mu2e
{

  class PrescaleEvent : public art::EDFilter {

  public:

    using  Name    = fhicl::Name;
    using  Comment = fhicl::Comment;

    struct EventModeConfig {
      //fhicl::Atom<uint8_t>        eventMode{ Name("eventMode"), Comment("EventMode: OnSpill, OffSpill, Calib, ...")};//FIXME!!
      fhicl::Atom<std::string>        eventMode{ Name("eventMode"), Comment("EventMode: OnSpill, OffSpill, Calib, ...")};//FIXME!!
      fhicl::Atom<float >         prescale { Name("prescale") , Comment("Prescale factor")};
    };

    struct Config {
      fhicl::Atom<int>                                 debug     { Name("debugLevel")     , Comment("Debug Level"), 0};
      fhicl::Sequence<fhicl::Table<EventModeConfig>>   eventMode { Name("eventModeConfig"), Comment("List of the Event modes with their PS factor")};
    };
    using        Parameters = art::EDFilter::Table<Config>;
    explicit     PrescaleEvent(const Parameters& conf);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    // Plugins should not be copied or assigned.

    PrescaleEvent(PrescaleEvent const &) = delete;
    PrescaleEvent(PrescaleEvent &&) = delete;
    PrescaleEvent & operator = (PrescaleEvent const &) = delete;
    PrescaleEvent & operator = (PrescaleEvent &&) = delete;

    bool filter(art::Event & e) override;
    virtual bool endRun(art::Run& run ) override;

  private:

    std::vector<EventModeConfig> _eventMode;
    int                  _debug;
    unsigned             _nevt, _npass;

  };

  PrescaleEvent::PrescaleEvent(Parameters const & config) :
    art::EDFilter{config},
    _eventMode     (config().eventMode()),
    _debug         (config().debug()),
    _nevt(0), _npass(0){}

  inline bool PrescaleEvent::filter(art::Event & e)
  {
    ++_nevt;

    // auto const& evtHH = e.getValidHandle<mu2e::EventHeader>("*");
    // uint8_t evtMode = evtHH->flags;
    // int     ps(0);
    // for (size_t i=0; i<_eventMode.size(); ++i){
    //   //      if (_eventMode[i].eventMode() == evtMode){
    //   if ((_eventMode[i].eventMode() & evtMode) == 1){
    //     ps = _eventMode[i].prescale();
    //     break;
    //   }
    // }
    int ps = _eventMode[0].prescale();

    bool retval(false);

    if(ps > 0) {
      retval = e.event() % ps == 0;
      if (retval){
        ++_npass;
      }
    }
    return retval;
  }

  bool PrescaleEvent::endRun( art::Run& run ) {
    if(_debug > 0){
      std::cout << moduleDescription().moduleLabel() << " passed " << _npass << " events out of " << _nevt << " for a ratio of " << float(_npass)/float(_nevt) << std::endl;
    }
    return true;
  }

}
using mu2e::PrescaleEvent;
DEFINE_ART_MODULE(PrescaleEvent)
