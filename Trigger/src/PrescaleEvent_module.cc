////////////////////////////////////////////////////////////////////////
// Class:       PrescaleEvent
// Module Type: filter
// File:        PrescaleEvent_module.cc
//
// Generated at Tue Jan  6 11:52:08 2015 by John Freeman using artmod
// from cetpkgsupport v1_07_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/types/Atom.h"
#include "fhiclcpp/types/Sequence.h"
#include "fhiclcpp/types/Table.h"
#include "canvas/Utilities/InputTag.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
// #include "RecoDataProducts/inc/TriggerInfo.hh"
#include "Offline/DataProducts/inc/EventWindowMarker.hh"
#include "artdaq-core-mu2e/Data/EventHeader.hh"

#include <memory>
#include <iostream>

namespace mu2e
{

  class PrescaleEvent : public art::EDFilter {

  public:

    using  Name    = fhicl::Name;
    using  Comment = fhicl::Comment;

    struct EventModeConfig {
      fhicl::Atom<std::string>   eventMode{ Name("eventMode"), Comment("EventMode: OnSpill, OffSpill, Calib, ...")};
      fhicl::Atom<int>           prescale { Name("prescale") , Comment("Prescale factor")};
    };

    struct EventMode {
      EventWindowMarker::SpillType _type;
      int _prescale;
      EventMode(EventWindowMarker::SpillType type, int prescale) : _type(type), _prescale(prescale) {}
    };

    struct Config {
      fhicl::Atom<art::InputTag>                       EWM       { Name("EventWindowMarker"), Comment("EventWindowMarker"),"EWMProducer"};
      fhicl::Atom<int>                                 debug     { Name("debugLevel")     , Comment("Debug Level"), 0};
      fhicl::Sequence<fhicl::Table<EventModeConfig>>   eventMode { Name("eventModeConfig"), Comment("List of the Event modes with their PS factor")};
    };
    using        Parameters = art::EDFilter::Table<Config>;
    explicit     PrescaleEvent(const Parameters& conf);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.
    // Plugins should not be copied or assigned.

    PrescaleEvent(PrescaleEvent const &) = delete;
    PrescaleEvent(PrescaleEvent &&) = delete;
    PrescaleEvent & operator = (PrescaleEvent const &) = delete;
    PrescaleEvent & operator = (PrescaleEvent &&) = delete;

    bool filter(art::Event & e) override;
    virtual bool endRun(art::Run& run ) override;

  private:

    art::ProductToken<EventWindowMarker> const _ewmtoken;
    std::vector<EventMode> _eventMode;
    int                    _debug;
    unsigned               _nevt, _npass;

  };

  PrescaleEvent::PrescaleEvent(Parameters const & config) :
    art::EDFilter{config},
    _ewmtoken{consumes<EventWindowMarker>(config().EWM())},
    _debug         (config().debug()),
    _nevt(0), _npass(0){
    for(const auto& mode : config().eventMode()) {
      if(mode.eventMode() == "OffSpill") _eventMode.push_back(EventMode(EventWindowMarker::offspill, mode.prescale()));
      else if(mode.eventMode() == "OnSpill") _eventMode.push_back(EventMode(EventWindowMarker::onspill, mode.prescale()));
      else throw cet::exception("TRIGGER") << "Unknown prescale mode " << mode.eventMode();
    }
  }

  inline bool PrescaleEvent::filter(art::Event & e)
  {
    ++_nevt;

    // Check for the prescale corresponding to the current event mode
    auto ewmH = e.getValidHandle(_ewmtoken);
    const EventWindowMarker& ewm(*ewmH);
    int ps(0); // default to filtering all events
    for (const auto& mode : _eventMode) {
      uint8_t spillType = mode._type;
      if (spillType == ewm.spillType()){
        ps = mode._prescale;
        break;
      }
    }

    // Default to false
    bool retval(false);

    // Apply the prescale, if requested for this event type
    if(ps > 0) {
      retval = e.event() % ps == 0;
      if (retval){
        ++_npass;
      }
    }

    // Return the result
    return retval;
  }

  bool PrescaleEvent::endRun( art::Run& run ) {
    if(_debug > 0){
      std::cout << moduleDescription().moduleLabel() << " passed " << _npass << " events out of " << _nevt
                << " for a ratio of " << ((_nevt > 0) ? float(_npass)/float(_nevt) : 0.f) << std::endl;
    }
    return true;
  }

}
using mu2e::PrescaleEvent;
DEFINE_ART_MODULE(PrescaleEvent)
