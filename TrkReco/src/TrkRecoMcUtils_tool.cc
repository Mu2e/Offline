///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////
#include "art/Framework/Principal/Event.h"
#include "fhiclcpp/ParameterSet.h"
#include "art/Utilities/ToolMacros.h"

#include "BTrk/BbrGeom/HepPoint.h"
#include "BTrk/BbrGeom/TrkLineTraj.hh"

#include "BTrk/TrkBase/HelixTraj.hh"
#include "BTrk/TrkBase/TrkPoca.hh"

#include "Offline/BTrkData/inc/TrkStrawHit.hh"

#include "Offline/GlobalConstantsService/inc/GlobalConstantsHandle.hh"
#include "Offline/GlobalConstantsService/inc/PhysicsParams.hh"

#include "CLHEP/Matrix/Vector.h"

#include "Offline/MCDataProducts/inc/StrawDigiMC.hh"

#include "Offline/MCDataProducts/inc/StepPointMC.hh"

#include "Offline/RecoDataProducts/inc/ComboHit.hh"

#include "Offline/TrackerGeom/inc/Straw.hh"

#include "Offline/Mu2eUtilities/inc/McUtilsToolBase.hh"

namespace mu2e {

  class TrkRecoMcUtils : public mu2e::McUtilsToolBase {
  protected:
    art::InputTag                 _comboHitCollTag;
    const ComboHitCollection*     _chColl;
    art::InputTag                 _strawDigiMCCollTag;
    const StrawDigiMCCollection*  _mcdigis;
    art::EventID                  _lastEvent;
    double                        _mbtime;

  public:

    TrkRecoMcUtils(const fhicl::Table<McUtilsToolBase::Config>& config);
    ~TrkRecoMcUtils();

  public:

      int            initEvent(const art::Event* Event);

      virtual int    strawHitSimId(const art::Event* Event, int Index) override;

      virtual double mcDoca(const art::Event* Event, const TrkStrawHit* StrawHit) override;
      // int               Index,
      // const Straw*      Straw) override ;

      // virtual int    nGenHits(const art::Event*         Event      ,
      //          const StrawHitCollection* Shcol      ) override;

      // virtual const StrawDigiMCCollection* getListOfMcStrawHits(const art::Event* Event,
      //                    const art::InputTag& Tag) override;

      virtual const SimParticle* getSimParticle(const art::Event* Event, int HitIndex) override;
      virtual const XYZVectorF*  getMom        (const art::Event* Event, int HitIndex) override;
      virtual const XYZVectorF*  getPos        (const art::Event* Event, int HitIndex) override;

      int   getID         (const SimParticle* Sim) override;
      int   getMotherID   (const SimParticle* Sim) override;
      int   getMotherPdgID(const SimParticle* Sim) override;
      int   getPdgID      (const SimParticle* Sim) override;
      float getStartMom   (const SimParticle* Sim) override;

  };

//-----------------------------------------------------------------------------
  TrkRecoMcUtils::TrkRecoMcUtils(const fhicl::Table<McUtilsToolBase::Config>& config) :
    _comboHitCollTag   { config().comboHitCollTag()    },
    _strawDigiMCCollTag{ config().strawDigiMCCollTag() }
  {
    _lastEvent   = art::EventID();
    _mcdigis     = nullptr;
    _chColl      = nullptr;
    _mbtime      = -1;
  }

  //-----------------------------------------------------------------------------
  TrkRecoMcUtils::~TrkRecoMcUtils() {
  }

  //-----------------------------------------------------------------------------
  int TrkRecoMcUtils::initEvent(const art::Event* Event) {
    art::Handle<mu2e::StrawDigiMCCollection> mcdigiH;
    Event->getByLabel(_strawDigiMCCollTag,mcdigiH);
    if (mcdigiH.isValid()) _mcdigis = (mu2e::StrawDigiMCCollection*) mcdigiH.product();
    else                   _mcdigis = NULL;

    auto chcH = Event->getValidHandle<ComboHitCollection>(_comboHitCollTag);
    _chColl   = chcH.product();

    if (_mbtime < 0) {
      _mbtime      = GlobalConstantsHandle<PhysicsParams>()->getNominalDRPeriod();
    }
    _lastEvent = Event->id();

    return 0;
  }

  //-----------------------------------------------------------------------------
  // returns ID of the SimParticle corresponding to straw hit 'Index'
  //-----------------------------------------------------------------------------
  int TrkRecoMcUtils::strawHitSimId(const art::Event* Event, int HitIndex) {
    if (Event->id() != _lastEvent) initEvent(Event);
    return (*_mcdigis)[HitIndex].earlyStrawGasStep()->simParticle()->id().asInt();
  }
  //-----------------------------------------------------------------------------
  // find MC truth DOCA in a given straw
  // start from finding the right vector of StepPointMC's
  //-----------------------------------------------------------------------------
  double TrkRecoMcUtils::mcDoca(const art::Event* Event, const TrkStrawHit* StrawHit) {

    double mcdoca(-99.0);

    if (Event->id() != _lastEvent) initEvent(Event);

    const ComboHit* ch    = &StrawHit->comboHit();
    const Straw*    straw = &StrawHit->straw();

    CLHEP::Hep3Vector v1 = straw->getMidPoint();
    HepPoint p1(v1.x(),v1.y(),v1.z());

    int hitIndex = ch-&_chColl->at(0);

    auto const& step = (*_mcdigis)[hitIndex].earlyStrawGasStep();

    CLHEP::Hep3Vector v2 = step->position();
    HepPoint    p2(v2.x(),v2.y(),v2.z());

    TrkLineTraj trstraw(p1,straw->getDirection()  ,0.,0.);
    TrkLineTraj trstep (p2,GenVector::Hep3Vec(step->momentum()).unit(),0.,0.);

    TrkPoca poca(trstep, 0., trstraw, 0.);

    mcdoca = poca.doca();

    return mcdoca;
  }

  // //-----------------------------------------------------------------------------
  // // calculates N(MC hits) produced by the signal particle, SIM_ID = 1, with P > 100
  // //-----------------------------------------------------------------------------
  //   int TrkRecoMcUtils::nGenHits(const art::Event*         Event         ,
  //         const StrawHitCollection* Shcol         ) {

  //     //    static int     last_event(-1);
  //     //    static int     first_call(1);

  //     double  time_threshold(500.);
  //     int     n_gen_hits(  0 );
  // //-----------------------------------------------------------------------------
  // // update if new event
  // //-----------------------------------------------------------------------------
  //     if (Event->id() != _lastEvent) initEvent(Event);

  //     if (_mcdigis == NULL) return -1;

  //     double  pEntrance(.0);

  //     int nhits = Shcol->size();
  //     for (int i=0; i<nhits; i++) {
  //       const mu2e::StepPointMC*   *step = getStepPointMC(i);

  //       int gen_index(-1), sim_id(-1);

  //       if (step) {
  //  art::Ptr<mu2e::SimParticle> const& simptr = step->simParticle();

  //  if (simptr->fromGenerator()) gen_index = simptr->genParticle()->generatorId().id();
  //  else                         gen_index = -1;

  //  sim_id        = simptr->id().asInt();
  //       }

  //       if ((gen_index > 0) && (sim_id == 1)) {
  //  double step_time = step->time();
  //  step_time = fmod(step_time,_mbtime);
  //  if (step_time > time_threshold) {
  //    ++n_gen_hits;
  //    double pstep = step->momentum().mag();
  //    if (pstep > pEntrance) {
  //      pEntrance = pstep;
  //    }
  //  }
  //       }
  //     }

  //     if (pEntrance < 100. ) n_gen_hits = 0;

  //     return n_gen_hits;
  //   }

  //-----------------------------------------------------------------------------
  // const StrawDigiMCCollection* TrkRecoMcUtils::getListOfMcStrawHits(const art::Event* Event,const art::InputTag& Tag) {
  //   auto handle = Event->getValidHandle<StrawDigiMCCollection>(Tag);
  //   const StrawDigiMCCollection* coll = handle.product();
  //   return coll;
  // }

  //-----------------------------------------------------------------------------
  const SimParticle* TrkRecoMcUtils::getSimParticle(const art::Event* Event, int HitIndex) {

    if (Event->id() != _lastEvent) initEvent(Event);

    return (*_mcdigis)[HitIndex].earlyStrawGasStep()->simParticle().get();
  }

  //-----------------------------------------------------------------------------
  const XYZVectorF* TrkRecoMcUtils::getMom(const art::Event* Event, int HitIndex) {

    if (Event->id() != _lastEvent) initEvent(Event);

    return &(*_mcdigis)[HitIndex].earlyStrawGasStep()->momentum();
  }

  //-----------------------------------------------------------------------------
  const XYZVectorF* TrkRecoMcUtils::getPos(const art::Event* Event, int HitIndex) {

    if (Event->id() != _lastEvent) initEvent(Event);

    return &(*_mcdigis)[HitIndex].earlyStrawGasStep()->startPosition();
  }

  //-----------------------------------------------------------------------------
  int   TrkRecoMcUtils::getID      (const SimParticle* Sim) { return Sim->id().asInt();  }

  //-----------------------------------------------------------------------------
  int   TrkRecoMcUtils::getMotherID(const SimParticle* Sim) {

    const SimParticle* mother = Sim;
    while(mother->hasParent()) mother = mother->parent().get();
    return mother->id().asInt();
  }

  //-----------------------------------------------------------------------------
  int   TrkRecoMcUtils::getMotherPdgID(const SimParticle* Sim) {

    const SimParticle* mother = Sim;
    while(mother->hasParent()) mother = mother->parent().get();
    return mother->pdgId();
  }

  //-----------------------------------------------------------------------------
  int   TrkRecoMcUtils::getPdgID   (const SimParticle* Sim) { return Sim->pdgId();  }

  //-----------------------------------------------------------------------------
  float TrkRecoMcUtils::getStartMom(const SimParticle* Sim) {
    CLHEP::HepLorentzVector const& p = Sim->startMomentum();
    return sqrt(p.x()*p.x()+p.y()*p.y()+p.z()*p.z());
  }

  DEFINE_ART_CLASS_TOOL(TrkRecoMcUtils)
}
